"""
This type stub file was generated by pyright.
"""

from .operations import *


class DataProcessing:
    @staticmethod
    def grid_subsampling(points, features=..., labels=..., grid_size=..., verbose=...):
        """CPP wrapper for a grid subsampling (method = barycenter for points and
        features).

        Args:
            points: (N, 3) matrix of input points
            features: optional (N, d) matrix of features (floating number)
            labels: optional (N,) matrix of integer labels
            grid_size: parameter defining the size of grid voxels
            verbose: 1 to display

        Returns:
            Subsampled points, with features and/or labels depending of the input
        """
        ...

    @staticmethod
    def load_pc_semantic3d(filename):
        ...

    @staticmethod
    def load_label_semantic3d(filename):
        ...

    @staticmethod
    def load_pc_kitti(pc_path):
        ...

    @staticmethod
    def load_label_kitti(label_path, remap_lut):
        ...

    @staticmethod
    def knn_search(support_pts, query_pts, k):
        """KNN search.

        Args:
            support_pts: points you have, B*N1*3
            query_pts: points you want to know the neighbour index, B*N2*3
            k: Number of neighbours in knn search

        Returns:
            neighbor_idx: neighboring points indexes, B*N2*k
        """
        ...

    @staticmethod
    def data_aug(xyz, color, labels, idx, num_out):  # -> tuple[Unknown, Unknown, Unknown, Unknown]:
        ...

    @staticmethod
    def shuffle_idx(x):
        ...

    @staticmethod
    def shuffle_list(data_list):
        ...

    @staticmethod
    def IoU_from_confusions(confusions):  # -> Any:
        """Computes IoU from confusion matrices.

        Args:
            confusions: ([..., n_c, n_c] np.int32). Can be any dimension, the confusion matrices should be described by
        the last axes. n_c = number of classes

        Returns:
            ([..., n_c] np.float32) IoU score
        """
        ...

    @staticmethod
    def Acc_from_confusions(confusions):
        ...

    @staticmethod
    def get_class_weights(num_per_class):
        ...

    @staticmethod
    def invT(T):
        ...

    @staticmethod
    def world2cam(points, world_cam):  # -> Any:
        ...

    @staticmethod
    def cam2img(points, cam_img):  # -> tuple[Any, Unknown]:
        ...

    @staticmethod
    def cam2world(points, world_cam):  # -> Any:
        ...

    @staticmethod
    def remove_outside_points(points, world_cam, cam_img, image_shape):
        """Remove points which are outside of image.

        Args:
            points (np.ndarray, shape=[N, 3+dims]): Total points.
            world_cam (np.ndarray, shape=[4, 4]): Matrix to project points in
                lidar coordinates to camera coordinates.
            cam_img (p.array, shape=[4, 4]): Matrix to project points in
                camera coordinates to image coordinates.
            image_shape (list[int]): Shape of image.

        Returns:
            np.ndarray, shape=[N, 3+dims]: Filtered points.
        """
        ...
