from typing import Iterable, Optional, Sequence, overload, Tuple, Dict, Iterator, Union
from enum import Enum

from .. import core
from .. import geometry


class Geometry:
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self) -> Geometry: ...
    def is_empty(self) -> bool: ...


class Image(Geometry):
    channels: int
    columns: int
    device: core.Device
    dtype: core.Dtype
    rows: int

    @overload
    def __init__(
        self,
        rows: int = 0,
        cols: int = 0,
        channels: int = 1,
        dtype: core.Dtype = core.Dtype.Float32,
        device: core.Device = core.Device("CPU:0"),
    ) -> None: ...
    @overload
    def __init__(self, tensor: core.Tensor) -> None: ...
    def as_tensor(self) -> core.Tensor: ...
    def clear(self) -> Image: ...

    def clip_transform(
        self, scale: float, min_value: float, max_value: float, clip_fill: float = 0.0
    ) -> Image: ...
    def clone(self) -> Image: ...

    def colorize_depth(
        self, scale: float, min_value: float, max_value: float
    ) -> Image: ...
    def cpu(self) -> Image: ...
    def create_normal_map(self, invalid_fill: float = 0.0) -> Image: ...

    def create_vertex_map(
        self, intrinsics: core.Tensor, invalid_fill: float = 0.0
    ) -> Image: ...
    def cuda(self, device_id: int = 0) -> Image: ...
    def dilate(self, kernel_size: int = 3) -> Image: ...
    def filter(self, kernel: core.Tensor) -> Image: ...

    def filter_bilateral(
        self, kernel_size: int = 3, value_sigma: float = 20.0, dist_sigma: float = 10.0
    ) -> Image: ...
    def filter_gaussian(self, kernel_size: int = 3, sigma: float = 1.0) -> Image: ...
    def filter_sobel(self, kernel_size: int = 3) -> Tuple[Image, Image]: ...

    @classmethod
    def from_legacy_image(
        cls, image_legacy: geometry.Image, device: core.Device = core.Device("CPU:0")
    ) -> Image: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def linear_transform(self, scale: float = 1.0, offset: float = 0.0) -> Image: ...
    def pyrdown(self) -> Image: ...

    def resize(
        self, sampling_rate: float = 0.5, interp_type: InterpType = InterpType.Nearest
    ) -> Image: ...
    def rgb_to_gray(self) -> Image: ...
    @overload
    def to(self, device: core.Device, copy: bool = False) -> Image: ...

    @overload
    def to(
        self,
        dtype: core.Dtype,
        scale: Optional[float] = None,
        offset: float = 0.0,
        copy: bool = False,
    ) -> Image: ...
    def to_legacy_image(self) -> geometry.Image: ...


class InterpType(Enum):
    Cubic = ...
    Lanczos = ...
    Linear = ...
    Nearest = ...
    Super = ...


class PointCloud(Geometry):
    point: TensorMap
    @overload
    def __init__(self, device: core.Device) -> None: ...
    @overload
    def __init__(self, points: core.Tensor) -> None: ...
    @overload
    def __init__(self, map_keys_to_tensors: Dict[str, core.Tensor]) -> None: ...
    def append(self, other: PointCloud) -> PointCloud: ...
    def clone(self) -> PointCloud: ...
    def cpu(self) -> PointCloud: ...

    @classmethod
    def create_from_depth_image(
        cls,
        depth: Image,
        intrinsics: core.Tensor,
        extrinsics: core.Tensor = ...,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        stride: int = 1,
        with_normals: bool = False,
    ) -> PointCloud: ...

    @classmethod
    def create_from_rgbd_image(
        cls,
        rgbd_image: RGBDImage,
        intrinsics: core.Tensor,
        extrinsics: core.Tensor = ...,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        stride: int = 1,
        with_normals: bool = False,
    ) -> PointCloud: ...
    def cuda(self, device_id: int = 0) -> PointCloud: ...

    @classmethod
    def from_legacy(
        cls,
        pcd_legacy: geometry.PointCloud,
        dtype: core.Dtype = core.Dtype.Float32,
        device: core.Device = core.Device("CPU:0"),
    ) -> PointCloud: ...
    def get_center(self) -> core.Tensor: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def rotate(self, R: core.Tensor, center: core.Tensor) -> PointCloud: ...
    def scale(self, scale: float, center: core.Tensor) -> PointCloud: ...
    def to(self, device: core.Device, copy: bool = False) -> PointCloud: ...
    def to_legacy(self) -> geometry.PointCloud: ...
    def transform(self, transformation: core.Tensor) -> PointCloud: ...

    def translate(
        self, translation: core.Tensor, relative: bool = True
    ) -> PointCloud: ...
    def voxel_down_sample(self, voxel_size: float) -> PointCloud: ...


class RGBDImage(Geometry):
    aligned_: bool
    color: Image
    depth: Image
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, color: Image, depth: Image, aligned: bool = True) -> None: ...
    def are_aligned(self) -> bool: ...
    def clear(self) -> RGBDImage: ...
    def clone(self) -> RGBDImage: ...
    def cpu(self) -> RGBDImage: ...
    def cuda(self, device_id: int = 0) -> RGBDImage: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def to(self, device: core.Device, copy: bool = False) -> RGBDImage: ...
    def to_legacy_rgbd_image(self) -> geometry.RGBDImage: ...


class SurfaceMaskCode(Enum):
    ColorMap = ...
    DepthMap = ...
    NormalMap = ...
    VertexMap = ...


class TensorMap:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, primary_key: str) -> None: ...

    @overload
    def __init__(
        self, primary_key: str, map_keys_to_tensors: Dict[str, core.Tensor]
    ) -> None: ...
    def assert_size_synchronized(self) -> None: ...
    def erase(self, key: str) -> int: ...
    def get_primary_key(self) -> str: ...
    def is_size_synchronized(self) -> bool: ...
    def items(self) -> Iterator: ...
    def __getitem__(self, key: str) -> core.Tensor: ...
    def __setitem__(self, key: str, value: core.Tensor) -> TensorMap: ...


class TriangleMesh(Geometry):
    triangle: TensorMap
    vertex: TensorMap
    @overload
    def __init__(self, device: core.Device = core.Device("CPU:0")) -> None: ...

    @overload
    def __init__(
        self, vertex_positions: core.Tensor, triangle_indices: core.Tensor
    ) -> None: ...
    def clear(self) -> TriangleMesh: ...
    def clone(self) -> TriangleMesh: ...
    def cpu(self) -> TriangleMesh: ...
    def cuda(self, device_id: int = 0) -> TriangleMesh: ...

    @classmethod
    def from_legacy(
        cls,
        mesh_legacy: geometry.TriangleMesh,
        vertex_dtype: core.Dtype = core.float32,
        triangle_dtype: core.Dtype = core.int64,
        device: core.Device = core.Device("CPU:0"),
    ) -> TriangleMesh: ...
    def get_center(self) -> core.Tensor: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def has_valid_material(self) -> bool: ...
    def rotate(self, R: core.Tensor, center: core.Tensor) -> TriangleMesh: ...
    def scale(self, scale: float, center: core.Tensor) -> TriangleMesh: ...
    def to(self, device: core.Device, copy: bool = False) -> TriangleMesh: ...
    def to_legacy(self) -> geometry.TriangleMesh: ...
    def transform(self, transformation: core.Tensor) -> TriangleMesh: ...

    def translate(
        self, translation: core.Tensor, relative: bool = True
    ) -> TriangleMesh: ...


class VoxelBlockGrid:
    def __init__(
        self,
        attr_names: Sequence[str],
        attr_dtypes: Sequence[core.Dtype],
        attr_channels: Sequence[Union[Iterable, int]],
        voxel_size: float = 0.0058,
        block_resolution: int = 16,
        block_count: int = 10000,
        device: core.Device = core.Device("CPU:0"),
    ) -> None: ...
    def attribute(self, attribute_name: str) -> core.Tensor: ...

    @overload
    def compute_unique_block_coordinates(
        self,
        depth: Image,
        intrisic: core.Tensor,
        extrinsic: core.Tensor,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        trunc_voxel_multiplier: float = 8.0,
    ) -> core.Tensor: ...

    @overload
    def compute_unique_block_coordinates(
        self,
        pcd: PointCloud,
        trunc_voxel_multiplier: float = 8.0,
    ) -> core.Tensor: ...

    def extract_point_cloud(
        self, weight_threshold: float = 3.0, estimated_point_number: int = -1
    ) -> PointCloud: ...

    def extract_triangle_mesh(
        self, weight_threshold: float = 3.0, estimated_point_number: int = -1
    ) -> TriangleMesh: ...
    def hashmap(self) -> core.HashMap: ...

    @overload
    def integrate(
        self,
        block_coords: core.Tensor,
        depth: Image,
        color: Image,
        depth_intrinsic: core.Tensor,
        color_intrinsic: core.Tensor,
        extrinsic: core.Tensor,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        trunc_voxel_multiplier: float = 8.0,
    ) -> None: ...

    @overload
    def integrate(
        self,
        block_coords: core.Tensor,
        depth: Image,
        color: Image,
        intrinsic: core.Tensor,
        extrinsic: core.Tensor,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        trunc_voxel_multiplier: float = 8.0,
    ) -> None: ...

    @overload
    def integrate(
        self,
        block_coords: core.Tensor,
        depth: Image,
        intrinsic: core.Tensor,
        extrinsic: core.Tensor,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        trunc_voxel_multiplier: float = 8.0,
    ) -> None: ...
    @classmethod
    def load(cls, file_name: str) -> VoxelBlockGrid: ...

    def ray_cast(
        self,
        block_coords: core.Tensor,
        intrinsic: core.Tensor,
        extrinsic: core.Tensor,
        width: int,
        height: int,
        render_attributes: Sequence[str] = ["depth", "color"],
        depth_scale: float = 1000.0,
        depth_min: float = 0.1,
        depth_max: float = 3.0,
        weight_threshold: float = 3.0,
        trunc_voxel_multiplier: float = 8.0,
        range_map_down_factor: int = 8,
    ) -> TensorMap: ...
    def save(self, file_name: str) -> None: ...
    def voxel_coordinates(self, voxel_indices: core.Tensor) -> core.Tensor: ...

    @overload
    def voxel_coordinates_and_flattened_indices(
        self, buf_indices: core.Tensor
    ) -> Tuple[core.Tensor, core.Tensor]: ...

    @overload
    def voxel_coordinates_and_flattened_indices(
        self,
    ) -> Tuple[core.Tensor, core.Tensor]: ...
    @overload
    def voxel_indices(self, buf_indices: core.Tensor) -> core.Tensor: ...
    @overload
    def voxel_indices(self) -> core.Tensor: ...
